#!/usr/bin/perl

use strict;
use warnings;
use Fcntl qw(LOCK_EX LOCK_NB);
use File::Slurp 'read_file';
use IO::Handle;

my $dir = ".";

################################################################################

# batch({ EXT => FUNCTION[, ...] }, DIR);
#
# For each file in DIR, run FUNCTION for the file with the matching file EXT
# (e.g. '.txt'). When FUNCTION return true, the batch job counter will be
# incremented and DIR will be re-scanned and reprocessed from the beginning
# (useful for parallel processing). To avoid processing the same batch file
# repeatedly, either rename it (giving it a different file EXT) or maintain
# your own list of already processed batch files.
sub batch {
    my ($subs, $dir) = @_;
    my $ext_re = join("|", map { quotemeta($_) } keys %$subs);
    my $count = 0;
  BATCH_FILE: {
        opendir(my $dh, $dir) or die "Failed to open dir '$dir' for reading: $!\n";
      LINE: while (defined(my $file = readdir($dh))) {
            my ($base, $ext) = $file =~ /^(.*?)($ext_re)$/ or next LINE;
            if (exists $subs->{$ext}) {
                $subs->{$ext}($base, $ext) and do {
                    $count += 1;
                    redo BATCH_FILE;
                };
            }
        }
    }
    return $count;
}

# Delete specified '.log' file unless it has a corresponding '.todo' file.
sub cleanup_indexing_logfile {
    my ($base, $ext) = @_;
    if (not -e "$base.todo") {
        unlink("$base.log") or die "Failed to delete file '$base.log': $!\n";
        warn "Deleted orphaned log file: $base.log\n";
    }
    return ();
}

# Return true after having processed a file, false of no lock could be
# established on that file.
#
# Multiple Processes and Race Conditions
# ======================================
# 1. An exclusive lock on 'batch.todo' file must exist throughout the
#    'batch.log' file's existence. (We can then use the lock to determine if a
#    batch job is currently in progress, without any race conditions.)
#
# 2. 'batch.log' must be deleted only after 'batch.todo' has been marked as
#    done by renaming it 'batch.done'. This way, if the 'batch.todo' job ever
#    crashes, it can always be resumed (since the logfile will always exist).
#
sub process_indexing_todofile {
    my ($base, $ext) = @_;
    open(my $todo, "<", "$base.todo") or die "Failed to open batch file '$base.todo' for reading: $!";
    flock($todo, LOCK_EX | LOCK_NB) or do {
        warn "Skipping currently running batch: $base.todo\n";
        return ();
    };
    my $todo_file = "$dir/$base.todo";
    my $done_file = "$dir/$base.done";
    my $log_file  = "$dir/$base.log";

    # Read previously processed ids from log (if any).
    my %already_done = (-e $log_file ? do {
        my @x = eval { read_file($log_file) };
        die "Failed to read file '$log_file': $!\n" if $@;
        map { chomp; ($_ => 1 ) } @x;
    } : ()) and warn "Resuming unfinished batch: $todo_file\n";

    open(my $log, ">>", $log_file)
        or die "Failed to open file '$log_file' for appending: $!";
    $log->autoflush();

    print "PROCESSING: '$todo_file'\n";
    while (defined(my $id = <$todo>)) {
        chomp($id);
        if (exists $already_done{$id}) {
            print "    '$id' -- already processed\n";
            next;
        }
        print "    '$id' -- processing\n";

        # index id   OR die "Failed to index!!"
        sleep 1;

        print $log "$id\n";
        $already_done{$id} = 1;
    }
    close($log)                    or die "Failed to close file '$log_file' after writing: $!\n";
    # Below order is super-important for atomicness!
    # (Rename '.todo' -> '.done' first, then delete logfile, close '.todo' last.)
    rename($todo_file, $done_file) or die "Failed to rename file '$todo_file' to '$done_file': $!\n";
    unlink($log_file)              or die "Failed to delete file '$log_file': $!\n";
    close($todo)                   or die "Failed to close file '$todo_file' after reading: $!\n";
    return 1;
}

################################################################################

my $file_funcs = {
    ".log"  => \&cleanup_indexing_logfile,
    ".todo" => \&process_indexing_todofile,
};

my $count = batch($file_funcs, $dir);
print $count == 0
    ? "No unstarted batches found in dir '$dir'\n"
    : "Processed $count batches in dir '$dir'\n";

#[eof]
