#!/usr/bin/perl

use strict;
use warnings;

=pod

CLEANUP_STALE_JOBS:
    for each doing/batch.pid file
        if exists doing/batch
            if (PID, CMD) = read doing/batch.pid then
                if PID exists and is CMD then
                    next doing/BATCH file
        # job is stale
        remove doing/batch.pid
        rename doing/batch.log todo/batch.log
        rename doing/batch todo/batch

# NOTE: On race conditions: The pid file needs to be created before we do *any*
# work on a batch job, and not removed until *everything* is finished, this
# avoid race conditions when starting parallel threads and cleaning up stale
# jobs.
START_JOB:
    batch = name of first batch file
    # To avoid races between other processes doing the same thing at the same
    # time, if pid file already exist we should fail and we should continue try
    # again with the next file in the directory.
    create doing/batch.pid without overwriting
        or restart from START_JOB
    rename todo/batch -> doing/batch
        or die "This should never happen"
    # Here we know we're the only process processing this file.
    open doing/batch
       process doing/batch


=cut


use Cwd 'realpath';

my $dir = ".";


################################################################################

# Usage: read_dir DIR[, IGNORE...]
#
# In scalar context: Return first file/dir name in DIR (or 'undef' if DIR is
# empty).
#
# In list context: Return list of files in dir (empty list if dir is empty).
#
# Files/dirs listed as IGNORE(s) (in addition to '.' and '..') will be be
# ignored when reading the directory.

# FIXME: replace @ignore_file with MATCHING regex
sub read_dir {
    my ($dir, @ignore_file) = @_;
    my %ignore = map { ($_ => 1) } (".", "..", @ignore_file);
    opendir(my $fh, $dir) or die "Failed to open dir '$dir' for reading: $!\n";
    my @file;
    while (defined(my $file = readdir $fh)) {
        next if $ignore{$file};
        push @file, $file;
        last unless wantarray;
    }
    closedir($fh) or die("Failed to close dir '$dir' after reading: $!\n");
    return wantarray ? @file : $file[0];
}

# Return false if file already exists (in which case it will not be
# overwritten), true if it could be written. die() on failures.
sub write_file_noclobber {
    my ($file, @data) = @_;
    use Fcntl qw(O_WRONLY O_CREAT O_EXCL);
    sysopen(my $fh, $file, O_WRONLY | O_CREAT | O_EXCL)
        or return (); #die "Failed to open file '$file' for writing: $!\n";

    #open(my $fh, ">", $file) or die "Failed to open file '$file' for writing: $!\n";
    print $fh @data;
    close($fh) or die "Failed to close file '$file' after writing: $!\n";
    return 1;
}

sub read_file {
    my ($file) = @_;
    open(my $fh, "<", $file) or return ();
    my @data = <$fh>;
    chomp(@data);
    close($fh) or die "Failed to close file '$file' after reading: $!\n";
    return wantarray ? @data : $data[0];
}

sub delete_file {
    my ($file) = @_;
    unlink($file) or die "Failed to delete file '$file': $!\n";
}

sub rename_file {
    my ($file, $dest_dir) = @_;
    rename($file, $dest_dir)
        or die "Failed to move '$file' to dir '$dest_dir': $!\n";
}

################################################################################

my @ignore_file;

sub read_cmd {
    my ($pid) = @_;
    open(my $fh, "/proc/$pid/cmdline") or die "badly";
    local $/ = "\0";
    my @cmd = <$fh>;
    return @cmd;
}

sub cmd_path {
    my ($pid) = @_;
    return eval { realpath("/proc/$pid/exe") } // "";
}

my $me = cmd_path($$);

my $num = 0;
while (defined(my $file = read_dir($dir, @ignore_file))) {

    if ($file !~ m#\.todo#) {
        # Delete orphaned '.log' or '.pid' files.
        if ($file =~ m#^ (.*) \.(pid|log) $#x and not -e "$1.todo") {
            warn "Deleting orphaned $2 file '$file'\n";
            delete_file "$file";
        }
        #print "Will ignore '$file'\n";
        push @ignore_file, $file;
        next;
    }
    my ($base)    = $file =~ m#^(.*)\.todo$#;
    my $todo_file = "$dir/$base.todo";
    my $done_file = "$dir/$base.done";
    my $log_file  = "$dir/$base.log";
    my $pid_file  = "$dir/$base.pid";

    if (-e $pid_file) {                        # clean up a stale job
        my $pid = read_file($pid_file) // "";
        my $cmd = cmd_path($pid);
        if ($cmd eq $me) {
            warn "Indexing job '$file' is in progress\n";
            push @ignore_file, $file;
            next;
        }
        # We've found an orphaned index job.
        delete_file $pid_file;
        warn "Indexing job '$file' exited uncleanly, will resume it\n";
    }
    $num += 1;
    print "PROCESSING: '$todo_file'\n";
    write_file_noclobber("$pid_file", $$) or do {
        warn "    Job '$file' is already running\n";
        push @ignore_file, $file;
        next;
    };
    print "    Pidfile: '$pid_file' created\n";

    # Read previously processed ids from log (if any).
    my %already_done = map { ($_ => 1) } read_file($log_file);

    print "    Logging: '$log_file'\n";
    print "    Reading: '$todo_file'\n";
    open(my $log, ">>", $log_file)
        or die "Failed to open file '$log_file' for appending: $!";
    open(my $todo, "<", $todo_file)
        or die "Failed to open file '$todo_file' for reading: $!";
    select((select($log), $| = 1)[0]);         # don't buffer log
    while (defined(my $id = <$todo>)) {
        chomp($id);
        if (exists $already_done{$id}) {
            print "        '$id' -- done by previous job\n";
            next;
        }
        print "        '$id' -- processing\n";

        # index id   OR die "Failed to index!!"
        sleep 1;

        print $log "$id\n";
        $already_done{$id} = 1;
    }
    close($todo) or die "Failed to close file '$todo_file' after reading: $!\n";
    close($log)  or die "Failed to close file '$log_file' after writing: $!\n";

    print "    Finished\n";
    print "        renaming '$todo_file' => '$done_file'\n";
    rename_file($todo_file, $done_file);
    print "        deleting '$log_file'\n";
    delete_file($log_file);
    print "        deleting '$pid_file'\n";
    delete_file($pid_file);
}
if ($num == 0) {
    print "No '.todo' files found to process\n";
} else {
    print "Processed $num '.todo' files\n";
}

#return 1;
