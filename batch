#!/usr/bin/perl

use strict;
use warnings;
use Cwd 'realpath';
use Fcntl qw(LOCK_EX LOCK_NB);

my $dir = ".";

################################################################################

# Usage: read_dir DIR[, IGNORE...]
#
# In scalar context: Return first file/dir name in DIR (or 'undef' if DIR is
# empty).
#
# In list context: Return list of files in dir (empty list if dir is empty).
#
# Files/dirs listed as IGNORE(s) (in addition to '.' and '..') will be be
# ignored when reading the directory.

# FIXME: replace @ignore_file with MATCHING regex
sub read_dir {
    my ($dir, @ignore_file) = @_;
    my %ignore = map { ($_ => 1) } (".", "..", @ignore_file);
    opendir(my $fh, $dir) or die "Failed to open dir '$dir' for reading: $!\n";
    my @file;
    while (defined(my $file = readdir $fh)) {
        next if $ignore{$file};
        push @file, $file;
        last unless wantarray;
    }
    closedir($fh) or die("Failed to close dir '$dir' after reading: $!\n");
    return wantarray ? @file : $file[0];
}

sub read_file {
    my ($file) = @_;
    open(my $fh, "<", $file) or return ();
    my @data = <$fh>;
    chomp(@data);
    close($fh) or die "Failed to close file '$file' after reading: $!\n";
    return wantarray ? @data : $data[0];
}

sub delete_file {
    my ($file) = @_;
    unlink($file) or die "Failed to delete file '$file': $!\n";
}

sub rename_file {
    my ($file, $dest_dir) = @_;
    rename($file, $dest_dir)
        or die "Failed to move '$file' to dir '$dest_dir': $!\n";
}

################################################################################

#
# 1. An exclusive lock on 'batch.todo' file must exist throughout the
#   'batch.log' file's existence. (We can then use the lock to determine if a
#   job is currently in progress, without any race conditions.)
#
# 2. 'batch.log' must be deleted only after 'batch.todo' has been marked as
#    done by renaming it 'batch.done'. This way, if the 'batch.todo' job ever
#    crashes, it can always be resumed (since the logfile will always exist).
#
my $count = 0;
my @ignore_file;
while (defined(my $file = read_dir($dir, @ignore_file))) {

    if (not $file =~ m#\.todo#) {              # for non-'.todo' files
        if ($file =~ m#^ (.*) \.log $#x and not -e "$1.todo") {
            warn "Deleting orphaned log file '$file'\n";
            delete_file "$file";
        }
        push @ignore_file, $file;
        next;
    }

    my ($todo_file, $done_file, $log_file) = do {
        my ($base) = $file =~ m#^(.*)\.todo$#;
        ("$dir/$base.todo", "$dir/$base.done", "$dir/$base.log");
    };

    open(my $todo, "<", $todo_file)
        or die "Failed to open job file '$todo_file' for reading: $!";

    flock($todo, LOCK_EX | LOCK_NB) or do {
        warn "Job '$file' is in progress, won't touch\n";
        push @ignore_file, $file;
        next;
    };

    # Read previously processed ids from log (if any).
    my %already_done = map { ($_ => 1) } read_file($log_file);
    warn "Job '$file' is unfinished, resuming it\n" if %already_done;

    open(my $log, ">>", $log_file)
        or die "Failed to open file '$log_file' for appending: $!";
    select((select($log), $| = 1)[0]);         # don't buffer log

    print "PROCESSING: '$file'\n";
    $count += 1;
    while (defined(my $id = <$todo>)) {
        chomp($id);
        if (exists $already_done{$id}) {
            print "    '$id' -- done by previous job\n";
            next;
        }
        print "    '$id' -- processing\n";

        # index id   OR die "Failed to index!!"
        sleep 1;

        print $log "$id\n";
        $already_done{$id} = 1;
    }
    print "    Done\n";
    close($log) or die "Failed to close file '$log_file' after writing: $!\n";
    rename_file($todo_file, $done_file);       # 1. mark job as done by rename
    delete_file($log_file);                    # 2. delete progress log
    close($todo)                               # 3. release lock last
        or die "Failed to close file '$todo_file' after reading: $!\n";
}
if ($count == 0) {
    print "No '.todo' files found to process\n";
} else {
    print "Processed $count '.todo' files\n";
}

#[eof]
