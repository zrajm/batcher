#!/usr/bin/perl

use strict;
use warnings;
use Fcntl qw(LOCK_EX LOCK_NB);
use File::Slurp qw(read_dir);
use IO::Handle; # autoflush

my $batch_dir = "x";

################################################################################

# batch(DIR, { EXT => FUNCTION[, ...] });
#
# For each file in DIR, run FUNCTION for the file with the matching file EXT
# (e.g. '.txt'). When FUNCTION return true, the batch job counter will be
# incremented. Return the number of times a callback have returned true.
sub batch {
    my ($dir, $subs) = @_;
    my $ext_re = join("|", map { quotemeta($_) } keys %$subs);
    my $count = 0;
    my @batch_file = map { "$dir/$_" } sort eval { read_dir($dir) };
    die "Failed to read batch directory '$dir': $!\n" if $@;
    foreach my $file (@batch_file) {
        my ($base, $ext) = $file =~ /^(.*?)($ext_re)$/
            or next;
        if (ref($subs->{$ext} // "") eq "CODE") {
            $subs->{$ext}($base, $ext) and $count += 1;
        }
    }
    return $count;
}

# Delete specified '.log' file unless it has a corresponding '.todo' file.
sub cleanup_indexing_logfile {
    my ($base, $ext) = @_;
    if (not -e "$base.todo") {
        unlink("$base.log") or die "Failed to delete file '$base.log': $!\n";
        warn "Deleted orphaned log file: $base.log\n";
    }
    return ();
}

# Return true after having processed a file, false of no lock could be
# established on that file.
#
# Multiple Processes and Race Conditions
# ======================================
#
# 1. Uses an exclusive lock on the batch log file to make sure that only one
#    process work on the same batch. Also abort if the batch log file do not
#    still exists after getting the lock (some other process could possibly
#    have sneaked in, just before we got the lock, and finished the job and
#    removed the batch file). After we've gotten the lock, however, we know
#    we're the only one working on this batch file, and we only need to check
#    log file existence once.
#
# 2. 'batch.log' must be deleted only after 'batch.todo' has been marked as
#    done by renaming it 'batch.done'. This way, if the 'batch.log' job ever
#    crashes, it can always be resumed (since the log file will always exist).
#
sub process_indexing_todofile {
    my ($base, $ext) = @_;
    my $todo_file = "$base.todo";
    my $done_file = "$base.done";
    my $log_file  = "$base.log";

    # Open and lock log file, and make sure that it's still there afterwards.
    # (This should guarantee that we're alone in working on this batch, and
    # that no other process managed to complete it just before got the lock.)
    open(my $log, "+>>", $log_file)
        or die "Failed to open temp file '$log_file' for reading/writing: $!";
    flock($log, LOCK_EX | LOCK_NB) or do {
        if ($! eq "Resource temporarily unavailable") {
            warn "Skipping currently running batch: $todo_file\n";
            return ();
        }
        die "Failed to lock temp file '$log_file': $!\n";
    };
    if (not -e $log_file) {
        warn "Skipping already finished batch: $todo_file\n";
        return ();
    }

    open(my $todo, "<", "$todo_file") or do {
        if ($! eq "No such file or directory") {
            warn "Skipping already finished batch: $todo_file\n";
            return ();
        }
        die "Failed to open batch file '$todo_file' for reading: $!";
    };

    # Read previously processed ids from log (if any).
    seek($log, 0, 0);
    my %already_done = do {
        chomp(my @already_done = <$log>);
        map { ($_ => 1 ) } @already_done;
    } and warn "Resuming unfinished batch: $todo_file\n";
    $log->autoflush();

    print "PROCESSING: '$todo_file'\n";
    while (defined(my $id = <$todo>)) {
        chomp($id);
        if (exists $already_done{$id}) {
            print "    '$id' -- already processed\n";
            next;
        }
        print "    '$id' -- processing\n";

        # index id   OR die "Failed to index!!"
        sleep 1;

        print $log "$id\n";
        $already_done{$id} = 1;
    }
    rename($todo_file, $done_file) or die "Failed to rename file '$todo_file' to '$done_file': $!\n";
    close($todo)                   or die "Failed to close file '$todo_file' after reading: $!\n";
    unlink($log_file)              or die "Failed to delete file '$log_file': $!\n";
    close($log)                    or die "Failed to close file '$log_file' after writing: $!\n";
    return 1;
}

################################################################################

my $count = batch($batch_dir, {
    ".log"  => \&cleanup_indexing_logfile,
    ".todo" => \&process_indexing_todofile,
});
print $count == 0
    ? "No unstarted batches found in dir '$batch_dir'\n"
    : "Processed $count batches in dir '$batch_dir'\n";

#[eof]
