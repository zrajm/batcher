#!/usr/bin/perl

use strict;
use warnings;

=pod

CLEANUP_STALE_JOBS:
    for each doing/batch.pid file
        if exists doing/batch
            if (PID, CMD) = read doing/batch.pid then
                if PID exists and is CMD then
                    next doing/BATCH file
        # job is stale
        remove doing/batch.pid
        rename doing/batch.log todo/batch.log
        rename doing/batch todo/batch

# NOTE: On race conditions: The pid file needs to be created before we do *any*
# work on a batch job, and not removed until *everything* is finished, this
# avoid race conditions when starting parallel threads and cleaning up stale
# jobs.
START_JOB:
    batch = name of first batch file
    # To avoid races between other processes doing the same thing at the same
    # time, if pid file already exist we should fail and we should continue try
    # again with the next file in the directory.
    create doing/batch.pid without overwriting
        or restart from START_JOB
    rename todo/batch -> doing/batch
        or die "This should never happen"
    # Here we know we're the only process processing this file.
    open doing/batch
       process doing/batch



CLEANUP_STALE_JOBS:
    for each doing/batch.pid file
        if exists doing/batch
            if (PID, CMD) = read doing/batch.pid then
                if PID exists and is CMD then
                    next doing/BATCH file
        # job is stale
        remove doing/batch.pid
        rename doing/batch.log todo/batch.log
        rename doing/batch todo/batch

# NOTE: On race conditions: The pid file needs to be created before we do *any*
# work on a batch job, and not removed until *everything* is finished, this
# avoid race conditions when starting parallel threads and cleaning up stale
# jobs.
START_JOB:
    batch = name of first batch file
    # To avoid races between other processes doing the same thing at the same
    # time, if pid file already exist we should fail and we should continue try
    # again with the next file in the directory.
    open batch.todo for reading
    lock batch.todo exclusively
    create log
    # Here we know we're the only process processing this file.
    process batch.todo
    unlock batch.todo

=cut


use Cwd 'realpath';
use Fcntl qw(LOCK_EX LOCK_NB);

my $dir = ".";


################################################################################

# Usage: read_dir DIR[, IGNORE...]
#
# In scalar context: Return first file/dir name in DIR (or 'undef' if DIR is
# empty).
#
# In list context: Return list of files in dir (empty list if dir is empty).
#
# Files/dirs listed as IGNORE(s) (in addition to '.' and '..') will be be
# ignored when reading the directory.

# FIXME: replace @ignore_file with MATCHING regex
sub read_dir {
    my ($dir, @ignore_file) = @_;
    my %ignore = map { ($_ => 1) } (".", "..", @ignore_file);
    opendir(my $fh, $dir) or die "Failed to open dir '$dir' for reading: $!\n";
    my @file;
    while (defined(my $file = readdir $fh)) {
        next if $ignore{$file};
        push @file, $file;
        last unless wantarray;
    }
    closedir($fh) or die("Failed to close dir '$dir' after reading: $!\n");
    return wantarray ? @file : $file[0];
}

sub read_file {
    my ($file) = @_;
    open(my $fh, "<", $file) or return ();
    my @data = <$fh>;
    chomp(@data);
    close($fh) or die "Failed to close file '$file' after reading: $!\n";
    return wantarray ? @data : $data[0];
}

sub delete_file {
    my ($file) = @_;
    unlink($file) or die "Failed to delete file '$file': $!\n";
}

sub rename_file {
    my ($file, $dest_dir) = @_;
    rename($file, $dest_dir)
        or die "Failed to move '$file' to dir '$dest_dir': $!\n";
}

################################################################################

my $count = 0;
my @ignore_file;
while (defined(my $file = read_dir($dir, @ignore_file))) {

    if (not $file =~ m#\.todo#) {              # for non-'.todo' files
        if ($file =~ m#^ (.*) \.log $#x and not -e "$1.todo") {
            warn "Deleting orphaned log file '$file'\n";
            delete_file "$file";
        }
        push @ignore_file, $file;
        next;
    }

    my ($todo_file, $done_file, $log_file) = do {
        my ($base) = $file =~ m#^(.*)\.todo$#;
        ("$dir/$base.todo", "$dir/$base.done", "$dir/$base.log");
    };

    open(my $todo, "<", $todo_file)
        or die "Failed to open job file '$todo_file' for reading: $!";
    flock($todo, LOCK_EX | LOCK_NB) or do {
        warn "Indexing job '$file' is still in progress\n";
        push @ignore_file, $file;
        next;
    };

    # Read previously processed ids from log (if any).
    my %already_done = map { ($_ => 1) } read_file($log_file);
    warn "Indexing job '$file' exited uncleanly, will resume it\n"
        if %already_done;

    open(my $log, ">>", $log_file)
        or die "Failed to open file '$log_file' for appending: $!";
    select((select($log), $| = 1)[0]);         # don't buffer log

    print "PROCESSING JOB: '$file'\n";
    print "    Logging: '$log_file'\n";
    print "    Reading: '$todo_file'\n";
    $count += 1;
    while (defined(my $id = <$todo>)) {
        chomp($id);
        if (exists $already_done{$id}) {
            print "        '$id' -- done by previous job\n";
            next;
        }
        print "        '$id' -- processing\n";

        # index id   OR die "Failed to index!!"
        sleep 1;

        print $log "$id\n";
        $already_done{$id} = 1;
    }
    close($todo) or die "Failed to close file '$todo_file' after reading: $!\n";
    close($log)  or die "Failed to close file '$log_file' after writing: $!\n";

    print "    Finished\n";
    print "        Renaming '$todo_file' => '$done_file'\n";
    print "        Deleting '$log_file'\n";
    rename_file($todo_file, $done_file);
    delete_file($log_file);
}
if ($count == 0) {
    print "No '.todo' files found to process\n";
} else {
    print "Processed $count '.todo' files\n";
}

#return 1;
